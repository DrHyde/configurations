set nocompatible

" -------------------- Vundle setup start
" see https://github.com/VundleVim/Vundle.vim#quick-start

filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

" " The following are examples of different formats supported.
" " Keep Plugin commands between vundle#begin/end.
"
" " plugin on GitHub repo
" Plugin 'tpope/vim-fugitive'
"
" " plugin from http://vim-scripts.org/vim/scripts.html
" Plugin 'L9'
"
" " Git plugin not hosted on GitHub
" Plugin 'git://git.wincent.com/command-t.git'
"
" " git repos on your local machine (i.e. when working on your own plugin)
" Plugin 'file:///home/gmarik/path/to/plugin'
"
" " The sparkup vim script is in a subdirectory of this repo called vim.
" " Pass the path to set the runtimepath properly.
" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
"
" " Install L9 and avoid a Naming conflict if you've already installed a
" " different version somewhere else.
" Plugin 'ascenator/L9', {'name': 'newL9'}

Plugin 'vim-perl/vim-perl'
Plugin 'rust-lang/rust.vim'
Plugin 'yggdroot/indentline'
Plugin 'tpope/vim-characterize'   " ga to show Unicode char name etc
Plugin 'airblade/vim-gitgutter'   " show git status per line in the gutter
                                  " ]c / [c to jump around between hunks
Plugin 'mileszs/ack.vim'          " :Ack
Plugin 'DrHyde/gitsessions.vim'   " fork of wting/gitsessions.vim which can also auto-create sessions
Plugin 'bling/vim-airline'        " status bar. Replaces ...
    " set laststatus=2
    " highlight StatusLine   ctermfg=White ctermbg=Red  cterm=bold
    " highlight StatusLineNC ctermfg=White ctermbg=Blue cterm=none
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-rhubarb'        " make fugitive's GBrowse work with github
Plugin 'tommcdo/vim-fubitive'     " ... and likewise for Bitbucket
Plugin 'pseewald/anyfold'         " folding. Replaces ...
    " let perl_fold = 1
    " let perl_fold_blocks = 1
Plugin 'tpope/vim-commentary'     " gc<motion> to comment out a bunch of lines, or gc in visual mode
Plugin 'godlygeek/tabular'        " :Tab /... to tabularize (auto-align) stuff

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
"
" Brief help
" :PluginList       - lists configured plugins
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ

" -------------------- Vundle setup end

let g:gitsessions_auto_create_sessions = 1

let g:airline_theme='darkimproved'
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.maxlinenr = ''

set nofileignorecase
set nowildignorecase
set wildmode=longest,list,full
set wildmenu
set autoindent
set ruler
set expandtab
set shiftwidth=4
set softtabstop=4
set tabstop=4
set showmatch
set incsearch
set nojoinspaces
set cursorline
set splitright
set splitbelow

set number
set relativenumber
augroup numbertoggle
  autocmd!
  autocmd BufEnter,FocusGained,InsertLeave * set relativenumber
  autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber
augroup END

syntax on

" intelligent tab-completion
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-n>"
    endif
endfunction
" make tab-completion work better for perl
autocmd FileType perl setlocal iskeyword+=:
autocmd FileType perl setlocal complete+=klib/*,kt/*,klocal/*
autocmd FileType perl setlocal complete-=i

" auto-inserting line breaks in code is hateful
autocmd FileType perl,sh,sql,rust,c,cpp,xs,markdown,vim,conf setlocal textwidth=0

" { and } go to start/end of sub in perl
autocmd FileType perl nnoremap <buffer> { $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('sub.*{', 'cbe')<CR>
autocmd FileType perl nnoremap <buffer> } $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('sub.*{', 'cbe')<CR>%
" {f and }f go to start/end of fn in rust
autocmd FileType rust nnoremap <buffer> {f $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('fn.*{', 'cbe')<CR>
autocmd FileType rust nnoremap <buffer> }f $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('fn.*{', 'cbe')<CR>%
" {i and }i go to start/end of impl in rust
autocmd FileType rust nnoremap <buffer> {i $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('impl.*{', 'cbe')<CR>
autocmd FileType rust nnoremap <buffer> }i $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('impl.*{', 'cbe')<CR>%
" {s and }s go to start/end of struct in rust
autocmd FileType rust nnoremap <buffer> {s $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('struct.*{', 'cbe')<CR>
autocmd FileType rust nnoremap <buffer> }s $:let dc_brace_jump_w=winsaveview()<CR>:keeppattern :call search('struct.*{', 'cbe')<CR>%
" {}u goes back whence we came
autocmd FileType perl,rust nnoremap <buffer> {}u :call winrestview(dc_brace_jump_w)<CR>

" for gitgutter
autocmd FileType perl,sh,sql,rust,c,cpp,xs,markdown,vim,conf setlocal signcolumn=yes
set updatetime=100      " otherwise gitgutter is a bit rubbish
let g:gitgutter_map_keys = 0
nmap ) <Plug>(GitGutterNextHunk)
nmap ( <Plug>(GitGutterPrevHunk)
" mnemonic: Git Hunk Stage
nmap <leader>ghs <Plug>(GitGutterStageHunk)
" mnemonic: Git Hunk Revert
nmap <leader>ghr <Plug>(GitGutterUndoHunk)

" for anyfold
autocmd Filetype * AnyFoldActivate     " for all filetypes
let g:anyfold_fold_display=0           " don't show anyfold's minimal fold info, use normal foldtext
set foldlevel=99                       " all open by default
set foldtext=gitgutter#fold#foldtext() " indicate changed code in folds

" use the FZF plugin; path assumes fzf was installed using Homebrew
set rtp+=/usr/local/opt/fzf

" the default is too dark for a dark terminal background
highlight vimComment  ctermfg=LightBlue
highlight perlComment ctermfg=LightBlue
highlight shComment   ctermfg=LightBlue
highlight rubyComment ctermfg=LightBlue
highlight confComment ctermfg=LightBlue

" red on black, and still visible when the current line is highlighted
hi        Todo        ctermfg=9 ctermbg=0

highlight SignColumn      ctermbg=17
highlight GitGutterAdd    ctermbg=Black   ctermfg=Green
highlight GitGutterChange ctermbg=Black   ctermfg=Yellow
highlight GitGutterDelete ctermbg=Black   ctermfg=Red

highlight LineNr cterm=NONE ctermfg=DarkGrey ctermbg=none

highlight CursorLine term=bold cterm=bold ctermbg=242

" :Diff
function! s:DiffWithSaved()
  let filetype=&ft
  diffthis
  vnew | r # | normal! 1Gdd
  diffthis
  exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
com! Diff call s:DiffWithSaved()

" :VTerm
function! s:VerticalTerm()
    vspl
    term ++curwin ++close bash -l
endfunction
" :Term
function! s:HorizontalTerm()
    spl
    term ++curwin ++close bash -l
endfunction
com! VTerm call s:VerticalTerm()
com! Term call s:HorizontalTerm()

" \mw to mark a window, \pw to swap marked and current
function! MarkWindowSwap()
    let g:markedWinNum = winnr()
endfunction

function! DoWindowSwap()
    "Mark destination
    let curNum = winnr()
    let curBuf = bufnr( "%" )
    exe g:markedWinNum . "wincmd w"
    "Switch to source and shuffle dest->source
    let markedBuf = bufnr( "%" )
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' curBuf
    "Switch to dest and shuffle source->dest
    exe curNum . "wincmd w"
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' markedBuf
endfunction

nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>

augroup BgHighlight
    autocmd!
    autocmd WinEnter * set number
    autocmd WinLeave * set nonumber
augroup END

let g:session_autosave = "yes"
let g:session_autoload = "yes"

" A command to perltidy and return the cursor whence it came.
" This allows 3 modes of use:
"    - In normal mode Ctl+t or :Tidy will tidy the whole buffer
"    - In :command mode, you can say :4,11 Tidy to tidy line 4 to 11
"    - In Visual mode, hit Ctr+t or :Tidy to tidy the selected block
"
" Change the <C-t> mappings at the bottom to choose a different shortcut. ;)
"
" Courtesy of TehJim xxx *muwhaa*
"
function! g:PerlTidyWithoutMovingTheCursor(...)
    let b:cursorPos = getpos('.')

    " If we were called with params...
    if a:0 == 2
        execute "".a:1.",".a:2."!perltidy"

    " In normal mode, we want to do the whole buffer
    else
        :%!perltidy
    endif

    redraw!
    call cursor(b:cursorPos[1], b:cursorPos[2])
endfunction
command -range=% -nargs=* Tidy call g:PerlTidyWithoutMovingTheCursor(<args>)
nmap <C-t> :Tidy<CR>
vmap <C-t> :!perltidy<CR>

" Strip trailing spaces (mnemonic: Kill Space Invaders)
nmap <leader>ksi :let dc_ksi_w=winsaveview()<Bar>:keeppatterns :%s/\s\+$//e<Bar>call winrestview(dc_ksi_w)<CR>

" C-j/k to scroll the whole buffer without moving cursor
nmap <C-j> <C-y>
nmap <C-k> <C-e>
" p/P to auto-reindent what is pasted
" https://vim.fandom.com/wiki/Format_pasted_text_automatically
nnoremap p ]p
nnoremap P ]P

" vim-commentary
"
" the default mappings are silly. The mere existence of this  will
" prevent the plugin from creating them.
nmap gc <nop>
" com<movement> to comment out a bunch of lines
xmap <leader>com  <Plug>Commentary
nmap <leader>com  <Plug>Commentary
omap <leader>com  <Plug>Commentary
" <number>comc to comment out <number> lines
nmap <leader>comc <Plug>CommentaryLine
" comu to uncomment the current commented block
nmap <leader>comu <Plug>Commentary<Plug>Commentary
